<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="KeleLiu">





<title>代码随想录---十.单调栈 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Keleliu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Keleliu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">代码随想录---十.单调栈</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">KeleLiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 12, 2023&nbsp;&nbsp;20:43:45</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>[toc]<br><font face="Times New Roman" color=black size=3 >文档中列出的是根据自己的思考，再结合<a target="_blank" rel="noopener" href="https://www.programmercarl.com/">代码随想录</a>和<a target="_blank" rel="noopener" href="https://leetcode.com/">LeetCode官网</a>的答案，自己作出的总结。同时在解题过程中会有一些自己的想法和辅助函数都一并列出，LeetCode对应题目链接在各题目处给出，完整的解题代码可访问本人的<a target="_blank" rel="noopener" href="https://github.com/kelearnliu/Cpp-code">GitHub</a>得到. </font></p>
<h3 id="1-每日温度"><a href="#1-每日温度" class="headerlink" title="1.每日温度"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E6%80%9D%E8%B7%AF">1.每日温度</a></h3><p>解法一：暴力求解<br>这里涉及到三个vector，输入的temperatures，输出的ans和中间用于计算ans的next。<br>初始化时ans的大小与temperatures相同，值为0；<br>next的大小为101，值为INT_MAX，存放的是对应温度首次出现的值，比如next[73]&#x3D;4,代表温度为73的那天是在原始数组中的序数为4的位置。<br>算法思路是：从后往前遍历temperatures的元素，比方示例中的最后一个元素是73，此时的i&#x3D;7，值t&#x3D;73，就要去next数组中去找next[74<del>100]中比t大的值，此例中就是next[73]&#x3D;7;由于初始化的next数组中值为INT_MAX，那么找不到比它大的，所以直接更新<br>Next[temperatures [7]]&#x3D;next[73]&#x3D;7,ans[7]&#x3D;0，不作出修改。<br>然后i减少，当i&#x3D;6时，值t&#x3D;76，此时要去查next[77</del>100]中比t大的值，同理还是没有，更新next[temperatures[6]]&#x3D;next[76]&#x3D;6,ans[6]&#x3D;0<br>然后i减少，当i&#x3D;5时， 值t&#x3D;72,查next[73~100]中比t大的值，并记住其序号，warmerIndex&#x3D;INT_MAX,<br>warmerIndex &#x3D; min(warmerIndex, next[73])&#x3D;min(INT_MAX,7)&#x3D;7,…<br>warmerIndex &#x3D; min(warmerIndex, next[76])&#x3D;min(7,6)&#x3D;6,<br>遍历完next以后，更新ans[5]&#x3D; warmerIndex-i&#x3D;6-5&#x3D;1;</p>
<p>不断进行即可，时空复杂度O(n*m)(n是输入数组长度，m是next数组中比较的数量&lt;&#x3D;100)&#x3D;O(n), O(m)</p>
<p>解法二：单调栈<br>使用一个栈，栈顶元素就是当前温度最大值所对应的天数，只有当后面的比前面天数的温度高时，才弹栈，否则就存着，说明温度还未增高。<br>思路类似于俄罗斯方块，当满足条件时，弹栈（类比于消除），这个条件就是(!stack.empty &amp;&amp; temperatures[i]&gt;temperatures[stack.top()])<br>栈不为空就继续判断是否要弹栈很好理解，后面这个是当后面的温度一定大于前面的时候才执行，否则就不执行。<br>不管前面是否消除，一定要将当前值压栈，这也就是为什么要在最后统一stack.push(i), 因为消除的是前面的元素，后面的必须压入来进行后续的比较。核心代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!dayIndex.<span class="built_in">empty</span>() &amp;&amp; temperatures[i]&gt;temperatures[dayIndex.<span class="built_in">top</span>()])&#123;</span><br><span class="line">    <span class="type">int</span> preIndex = dayIndex.<span class="built_in">top</span>();</span><br><span class="line">    ans[preIndex] = i-preIndex;</span><br><span class="line">    dayIndex.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>
<p>时空复杂度O(n), O(n)。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.每日温度：请根据每日 气温 列表，重新生成一个列表。</span></span><br><span class="line"><span class="comment">// 对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span></span><br><span class="line"><span class="comment">//给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperaturesBrute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 这里的next数组中，序号的含义是温度，值的含义是第一次出现这个温度的下标</span></span><br><span class="line">        <span class="comment">// ans数组最好初始化为0</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span>, <span class="title">next</span><span class="params">(<span class="number">101</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="built_in">printVector</span>(ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> warmerIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) &#123;</span><br><span class="line">                <span class="comment">// 这里的理解：比较的是next[t]的大小，也就是温度为t的值在temperature中出现的序号，比方说next[76]=6,那么就是min(Inf,6)</span></span><br><span class="line">                warmerIndex = <span class="built_in">min</span>(warmerIndex, next[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex != INT_MAX) &#123;</span><br><span class="line">                ans[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新next数组中温度出现的最小值</span></span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line"><span class="comment">//            PrintVector(next);</span></span><br><span class="line"><span class="comment">//            PrintVector(ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperaturesMonoStack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 这里面的栈顶元素是当前最高温度所对应的天数序号，从0开始的</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; dayIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果满足条件，就弹栈并且更新ans数组中的值</span></span><br><span class="line">            <span class="keyword">while</span>(!dayIndex.<span class="built_in">empty</span>() &amp;&amp; temperatures[i]&gt;temperatures[dayIndex.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> preIndex = dayIndex.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">// 满足条件才给ans赋值，也就是说，只有当后面的值比前面的值大的情况下，才会修改ans数组，否则ans保持为0</span></span><br><span class="line">                ans[preIndex] = i-preIndex;</span><br><span class="line">                dayIndex.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不满足条件，也就是说还没有达到最高的温度，就压栈</span></span><br><span class="line">            <span class="comment">// 或者已经弹栈以后，将新的元素压入，用以后面的比较</span></span><br><span class="line">            dayIndex.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2-下一个更大元素I"><a href="#2-下一个更大元素I" class="headerlink" title="2.下一个更大元素I"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html">2.下一个更大元素I</a></h3><p><strong>解法一：</strong> 使用暴力求解的方法，里面有两个while循环，<br>第一个while：寻找到num2数组中和num1数组的当前值相等时的序号<br>第二个while：在num2中找到的序号开始，继续寻找比num1中当前值大的值<br>当第二个while遍历完之后，如果序号比num2的长度长，那么就是没有返回-1，否则就返回当前的序号所对应的值</p>
<p><strong>解法二：</strong> 使用单调栈<br>思路是从右向左开始遍历，<br>从第一个先入栈，<br>从第二个值开始算法，<br>如果比前面的值大，说明前面这个数值就是我们要找的值，直接放入结果数组，<br>如果比前面的值小，说明当前的值更大，只要比当下值大，单调栈就弹栈，如果最后单调栈为空了，说明前面值没有比当前值大，返回-1，否则就返回栈顶元素即可。<br><strong>解法三：</strong> 使用前一题的方法，前一题生成的是比当前值大的值出现在哪一个位置，所以只需要将序号转换成值就可以，最后用map保存。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.下一个更大元素 I</span></span><br><span class="line"><span class="comment">// nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</span></span><br><span class="line"><span class="comment">// nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出[-1,3,-1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1.使用暴力求解方法，得到结果</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElementBrute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n1,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="comment">// 找到相等的元素所在的序号 在nums1中是第i个，在num2中是第j个</span></span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n2 &amp;&amp; nums1[i]!=nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到以后，在nums2中从第j个开始，找后面的比nums2[j]大的值</span></span><br><span class="line">            <span class="type">int</span> k=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;n2 &amp;&amp; nums2[k]&lt;nums2[j])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = k&lt;n2?nums2[k]:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.调用第一题中函数，直接得到一个ref数组,在这个基础上再进行修改，得到一个hashmap，最后查表得到结果</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElementCallMono</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ref = <span class="built_in">Solution1</span>().<span class="built_in">dailyTemperaturesMonoStack</span>(nums2);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(nums2.size())</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;num_map;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ref[i]==<span class="number">0</span>)</span><br><span class="line">                val[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                val[i]=nums2[i+ref[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index nums2   value val</span></span><br><span class="line"><span class="comment">//        PrintVector(nums2);</span></span><br><span class="line"><span class="comment">//        PrintVector(val);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            num_map[nums2[i]] = val[i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        PrintVector(nums1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp; i : nums1)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num_map[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.不调用第一个题中使用的单调栈接口，自己写一个</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElementMyMono</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num_map;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="comment">// 计算nums2的单调栈的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!index.<span class="built_in">empty</span>() &amp;&amp; num &gt; index.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                index.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            num_map[num] = index.<span class="built_in">empty</span>() ? <span class="number">-1</span> : index.<span class="built_in">top</span>();</span><br><span class="line">            index.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans[i] = num_map[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-下一个更大元素II"><a href="#3-下一个更大元素II" class="headerlink" title="3.下一个更大元素II"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html">3.下一个更大元素II</a></h3><p>这里使用的是循环数组，将[1,2,1]—&gt;[1,2,1,1,2];这样就能保证遍历一遍之后输出的数组能够完全将[1,2,1]的序号更新。如果使用的不是循环数组，在遍历原数组的时候，可能出现-1，只有完全遍历过两次之后（不包括最后一个，只需要2N-1个即可），就能够完全得到所有的序号。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;  stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()]&lt;nums[i%n])&#123;</span><br><span class="line">                ret[stk.<span class="built_in">top</span>()] = nums[i%n];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i%n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-接雨水"><a href="#4-接雨水" class="headerlink" title="4.接雨水"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">4.接雨水</a></h3><p><strong>方法一 动态规划</strong><br>核心思想在于计算第 <strong>$i$</strong> 个位置的左边和右边的最大值是多少，这样就能计算第 <strong>$i$</strong> 个位置的储水量，再遍历数组就能够得到整个数组的储水量。</p>
<p>所以现在要知道 <strong>$i$</strong> 左边和右边的最大值是多少，这里使用两个数组来保存 <strong>$leftMax$</strong> 和 **$rightMax$**。<br><strong>$leftMax[i]$</strong> 就代表第 <strong>$i$</strong> 个位置的左边最大值是多少，同理 <strong>$rightMax[i]$</strong> 就代表第 <strong>$i$</strong> 个位置的右边最大值是多少<br>举例子来讲，如果 <strong>$i&#x3D;3,height[i]&#x3D;0, leftMax[i]&#x3D;1,rightMax[i] &#x3D; 2 $</strong> 那么第 $3$ 个位置的储水量就是  **$min(2,1) - height(3)&#x3D;1-0&#x3D;1$**。<br>这里的算法复杂度是 <strong>$O(n^2)$</strong> 但是用动态规划的方法可以降到 <strong>$O(n)$</strong><br>算法内容：<br>对于 <strong>$leftMax$</strong> 数组<br>$$ leftMax[i]&#x3D;\begin{cases}<br>height[0] &amp; i&#x3D;0 \<br>max(leftMax[i-1],height[i]) &amp; 1&lt;i&lt;n-1<br>\end{cases}$$<br>当 $i!&#x3D;0$的时候，只需要比较当前的 $height[i]和leftMax[i-1]$的值就能够知道当前 $leftMax[i]$的值，这里就是动态规划的思想。<br>对于 <strong>$rightMax$</strong> 数组<br>$$ rightMax[i]&#x3D;\begin{cases}<br>height[n-1] &amp; i&#x3D;n-1 \<br>max(rightMax[i+1],height[i]) &amp; 0&lt;i&lt;n-2<br>\end{cases}$$</p>
<p>经过上面的处理就能直接用两个数组和原始数据求得总的储水量了。<br>时空复杂度都是 $O(n)$</p>
<p><strong>方法二 双指针</strong><br>相比于维护两个数组，这里只需要维护两个指针变量 $left,right$和两个变量$leftMax,rightMax$，这个思想很巧妙。 $left和right$只能向对方方向走，两者相等时说明遍历完成。$leftMax和rightMax$的作用是，只要有一边的值比另一边小，那就说明$left和right$所对应的地方一定可以储水，储水量为 $leftMax-height[left]$ 或者$rightMax-height[right]$。<br>每次只是计算当前 $i$ 的储水量，最后并加到总的储水量中去。</p>
<p>时间复杂度 $O(n)$<br>空间复杂度 $O(1)$ 只使用了4个变量来保存数据</p>
<p><strong>方法三 单调栈</strong><br>有点类似于括号匹配，先把左边的大的值存储在单调栈的栈底，当新的数值能够形成一个凹槽的时候，弹栈，这样的话就能先求得跨度小的凹槽的储水量，再求得跨度大的储水量。<br>在新的值和栈中的值相等的时候，维护前一个值。<br>关键在于比较单调栈中的当下两个元素，即 $left和top$，单调栈中存放的是数组的下表，但是比较的是数组下标的对应值。 也就是单调栈的栈顶元素是小的，栈底元素是大的。一旦出现了比栈顶元素大的 $height[i]$的值，就说明当前值和 $left$ 以及 $top$构成了一个凹槽，这个凹槽的高度是 $min(height[left],height[i])-height[top]$,宽度是 $i-left-1$,这样就能计算这个凹槽的储水量了。计算完之后，当前的 $left和top$弹栈，再将 $height[i]$作为 $left$压入栈中，重复。如果最后栈为空或者i&#x3D;height.size()，就说明完成了所有的遍历。</p>
<p>时空复杂度为 $O(n)$<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution11_4</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用动态规划算法来实现</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trapDynamic</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; height)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> totalValue=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(height.size(),height[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(height.size(),height[height.size()<span class="number">-1</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            leftMax[i]= leftMax[i<span class="number">-1</span>]&gt;height[i]?leftMax[i<span class="number">-1</span>]:height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=height.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightMax[i]=rightMax[i+<span class="number">1</span>]&gt;height[i]?rightMax[i+<span class="number">1</span>]:height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;原始的输入&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printVector</span>(height);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;leftMax数组&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printVector</span>(leftMax);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;rightMax数组&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printVector</span>(rightMax);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> ref = leftMax[i]&gt;rightMax[i]?rightMax[i]:leftMax[i];</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个位置的储水量为&quot;</span>&lt;&lt;ref-height[i]&lt;&lt;endl;</span><br><span class="line">            totalValue+=(ref-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双指针法实现</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trapDoublePointer</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用作计算储水的区间</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> leftMax=<span class="number">0</span>, rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">// 每一次都要更新Max的值</span></span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left]);</span><br><span class="line">            rightMax=<span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">                ans+=leftMax-height[left];</span><br><span class="line">                <span class="comment">// left指针指向下一个位置</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans+=rightMax-height[right];</span><br><span class="line">                <span class="comment">// right指针指向下一个位置</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trapMonoStack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; height[i]&gt;height[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> top=stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 这里保证了栈中最少有两个元素 因为如果只有一个元素的话就会直接break出去</span></span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left=stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> currWidth = i-left<span class="number">-1</span>;</span><br><span class="line">                <span class="type">int</span> currHeight = <span class="built_in">min</span>(height[left], height[i])-height[top];</span><br><span class="line">                ans += currHeight*currWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-最大矩形"><a href="#5-最大矩形" class="headerlink" title="5.最大矩形"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html">5.最大矩形</a></h2><p><strong>方法一 单调栈</strong><br>栈中存放的是数组的序号，序号对应的值时不断上升的，即只有新入栈的值大于栈顶元素的值，才将这个序号入栈。比如栈顶为1，对应$heights[1]&#x3D;1$,当$heights[2]&gt;&#x3D;heights[1]$时，才压栈，将序号2压入栈顶，否则就弹栈并计算。与上面接雨水的题不同，这里的单调栈里栈顶元素是最大的。当入栈的元素值小于栈顶时，说明以栈顶元素为高的矩形已经不会再扩展了，就要计算了。<br>这里还是用了首尾值为0的两个哨兵，尾部哨兵可以清空前面栈元素，计算出所有存放的序号对应的矩形值，因为尾部哨兵是0，比任何元素都要小，那么就会全部计算。首部哨兵是为了防止出现栈中元素小于2的情况，因为我们要当前元素，栈顶元素和栈顶元素的上一个元素，所以栈中必须有两个以上的元素。 时间复杂度为$O(n)$,空间复杂度为$O(n)$。</p>
<p><strong>方法二 双指针</strong><br>思想还是找到当前值左右两边最小值出现的位置，指针由当前值的位置初始化，然后分别向左向右寻找，这样的思想简单，但是时间复杂度是$O(n^2)$ 空间复杂度是O(1)</p>
<p><strong>方法三 动态规划</strong><br>对于双指针法的改进，用两个数组存储当前i对应的左右两边小于其值的序号，类似于接雨水中的$leftMax和rightMax$ 数组。以$leftMax$为例，由于第$i-1$处的值（即小于$i-1$为序号的值的向左最近的值的序号），可以不断动态更新。这里用空间换时间。时间复杂度为$O(n)$,空间复杂度为$O(n)$。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution11_5</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双指针法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleAreaDoublePointer</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义left和right两个指针，分别指向比当前位置的值小的前后节点的下表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = i, right = i;</span><br><span class="line">            <span class="comment">// 找左边小于当前值的序号</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[left] &lt; heights[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果还是比当前值大 就继续往前找</span></span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边小于当前值的序号</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; heights.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[right] &lt; heights[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果还是比当前值大 就继续往后找</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> h = heights[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, w * h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划 不同于前面双指针的地方在于，将之前的序号遍历并且存储起来，这样就能直接使用了</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleAreaDynamic</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这两个数组里面记录的是第i和位置左边和右边小于该值时对应的序号</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minLeftIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minRightIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> size=heights.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录左边小于该柱子的下标</span></span><br><span class="line">        minLeftIndex[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t &gt;= <span class="number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) &#123;</span><br><span class="line">                <span class="comment">// 如果序号t的值比当前序号i的值大，那么就更新t，所以不需写t的变化了</span></span><br><span class="line">                t = minLeftIndex[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上面的while条件不满足，说明找到了序号t对应的值比序号i对应的值小，那么就记录，找到了</span></span><br><span class="line">            minLeftIndex[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minRightIndex[size<span class="number">-1</span>]=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t&lt;size &amp;&amp; heights[t]&gt;heights[i])&#123;</span><br><span class="line">                t=minRightIndex[t];</span><br><span class="line">            &#125;</span><br><span class="line">            minRightIndex[i]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum = heights[i] * (minRightIndex[i]-minLeftIndex[i]<span class="number">-1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调栈的解法  这样的栈的写法处理了前面栈空的问题，但是无法解决数组中数据单调上升的情况</span></span><br><span class="line">    <span class="comment">// 所以还是要使用前后有两个哨兵的写法，这样就能保证尾部能够完全清空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleAreaMonoStack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="comment">// 这里尾部加一个哨兵 就能得到正确结果</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 测试了一下还是不行 要加两个哨兵</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> mid = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> currHeight = heights[mid];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, currWidth * currHeight);</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个ans=&quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-代码的其他部分"><a href="#6-代码的其他部分" class="headerlink" title="6.代码的其他部分"></a>6.代码的其他部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数 打印vector中的数字</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">printVector</span><span class="params">(vector&lt;T&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:v)&#123;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.每日温度</span></span><br><span class="line"><span class="comment">//    p1();</span></span><br><span class="line">    <span class="comment">// 2.下一个更大元素 I</span></span><br><span class="line"><span class="comment">//    p2();</span></span><br><span class="line">    <span class="comment">// 4 接雨水</span></span><br><span class="line"><span class="comment">//    p11_4();</span></span><br><span class="line">    <span class="comment">// 5 最大矩形</span></span><br><span class="line">    <span class="built_in">p11_5</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temperature=&#123;<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(temperature.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//    PrintVector(temperature);</span></span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution1</span>().<span class="built_in">dailyTemperaturesBrute</span>(temperature));</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution1</span>().<span class="built_in">dailyTemperaturesMonoStack</span>(temperature));</span><br><span class="line"><span class="comment">//    cout&lt;&lt;INT_MAX&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;INT_MIN&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;INT_MAX+1-INT_MIN&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1=&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums2=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution2</span>().<span class="built_in">nextGreaterElementBrute</span>(nums1,nums2));</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution2</span>().<span class="built_in">nextGreaterElementCallMono</span>(nums1,nums2));</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution2</span>().<span class="built_in">nextGreaterElementMyMono</span>(nums1, nums2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(<span class="built_in">Solution3</span>().<span class="built_in">nextGreaterElements</span>(nums1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p11_4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; height=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; height=&#123;4,2,3&#125;;</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">Solution11_4</span>().<span class="built_in">trapDynamic</span>(height)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">Solution11_4</span>().<span class="built_in">trapDoublePointer</span>(height)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">Solution11_4</span>().<span class="built_in">trapMonoStack</span>(height)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p11_5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; heights = &#123;2,1,5,6,2,3&#125;;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heights = &#123;<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Solution11_5</span>().<span class="built_in">largestRectangleAreaDoublePointer</span>(heights)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Solution11_5</span>().<span class="built_in">largestRectangleAreaDynamic</span>(heights)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Solution11_5</span>().<span class="built_in">largestRectangleAreaMonoStack</span>(heights)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>KeleLiu</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/C-LeetCode/"># C++, LeetCode</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/02/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95---%E5%85%AD.%E4%BA%8C%E5%8F%89%E6%A0%91/">代码随想录---六.二叉树</a>
            
            
            <a class="next" rel="next" href="/2023/02/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95---%E4%BA%94.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">代码随想录---五.栈与队列</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© KeleLiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>